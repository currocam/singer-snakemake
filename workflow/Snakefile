"""
Snakemake workflow for SINGER (github.com/popgenmethods/SINGER). Please cite
SINGER if you use this (note that I'm not an author of SINGER).

Part of https://github.com/nspope/singer-snakemake.
"""

import csv
import msprime
import tskit
import numpy as np
import allel
import matplotlib.pyplot as plt
import yaml
import pickle
import subprocess
import numba
from datetime import datetime

def tag(step): 
    return f"[singer-snakemake::{step}::{str(datetime.now())}]"

# ------ config ------ #

configfile: "config/example_config.yaml"

INPUT_DIR = config["input-dir"]
CHROMOSOMES = glob_wildcards(os.path.join(INPUT_DIR, "{chrom}.vcf")).chrom
CHUNK_SIZE = float(config["chunk-size"])
MAX_MISSING = float(config["max-missing"])
POLARISED = bool(config["polarised"])
MUTATION_RATE = float(config["mutation-rate"])
RECOMBINATION_RATE = float(config["recombination-rate"])
MCMC_THIN = int(config["mcmc-thin"])
MCMC_SAMPLES = int(config["mcmc-samples"])
MCMC_BURNIN = int(float(config["mcmc-burnin"]) * MCMC_SAMPLES)
MCMC_RESUMES = int(config["mcmc-resumes"] * MCMC_SAMPLES)
RAND_SEED = int(config["random-seed"])
COALRATE_EPOCHS = int(config["coalrate-epochs"])
STRATIFY_BY = config["stratify-by"]
SINGER_BINARY = config["singer-binary"] 

assert MCMC_SAMPLES > 0, "Number of MCMC samples must be nonzero"
assert MCMC_BURNIN < MCMC_SAMPLES, "Burn-in exceeds number of MCMC samples"
np.random.seed(RAND_SEED)
SEED_ARRAY = {n:x for n, x in zip(CHROMOSOMES, np.random.randint(2 ** 20, size=len(CHROMOSOMES)))}

# ------ rules ------ #

rule all:
    input:
        expand("results/{chrom}/site_density.png", chrom=CHROMOSOMES),
        expand("results/{chrom}/diversity-scatter.png", chrom=CHROMOSOMES),
        expand("results/{chrom}/{chrom}.{rep}.trees", chrom=CHROMOSOMES, rep=range(MCMC_SAMPLES)),
        expand("results/{chrom}/pair-coalescence-rates.png", chrom=CHROMOSOMES),


checkpoint chunk_chromosomes:
    """
    Chop up chromosome into chunks, adjust mutation rate to reflect missing
    data, calculate statistics in chunks, make some plots of site/missing data density.
    """
    input: 
        vcf = os.path.join(INPUT_DIR, "{chrom}.vcf"),
    output:
        site_density = "results/{chrom}/site_density.png",
        chunks = directory("results/{chrom}/chunks"),
        vcf_stats = "results/{chrom}/{chrom}.vcf.stats.p",
        ratemap = "results/{chrom}/{chrom}.adjusted_mu.p",
        metadata = "results/{chrom}/{chrom}.vcf.samples.p",
    log:
        log = "results/{chrom}/{chrom}.log"
    params:
        seed = lambda w: SEED_ARRAY[w.chrom],
        chunk_size = CHUNK_SIZE,
        mutation_rate = MUTATION_RATE,
        mcmc_samples = MCMC_SAMPLES,
        mcmc_thin = MCMC_THIN,
        polarised = POLARISED,
        max_missing = MAX_MISSING,
    script:
        "scripts/chunk_chromosomes.py"


rule run_singer:
    """
    Run SINGER chunk-by-chunk. Uses the "-resume" flag to resume sampling on
    error (see https://github.com/popgenmethods/SINGER/issues/13)
    """
    input:
        params = "results/{chrom}/chunks/{id}.yaml"
    output:
        recombs = expand("results/{{chrom}}/chunks/{{id}}_recombs_{rep}.txt", rep=range(MCMC_SAMPLES))
    log:
        out = "results/{chrom}/chunks/{id}.stdout",
        err = "results/{chrom}/chunks/{id}.stderr"
    params:
        mcmc_resumes = MCMC_RESUMES,
        singer_binary = SINGER_BINARY,
    script:
        "scripts/run_singer.py"


def merge_chunks_params(wildcards):
    dir = checkpoints.chunk_chromosomes.get(chrom=wildcards.chrom).output.chunks
    out = expand(
        os.path.join(dir, "{id}.yaml"),
        id=glob_wildcards(os.path.join(dir, "{id}.yaml")).id
    )
    return out

def merge_chunks_input(wildcards, regex):
    dir = checkpoints.chunk_chromosomes.get(chrom=wildcards.chrom).output.chunks
    out = expand(
        os.path.join(dir, f"{{id}}_{regex}_{{rep}}.txt"),
        rep=wildcards.rep,
        id=glob_wildcards(os.path.join(dir, "{id}.yaml")).id
    )
    return out

rule merge_chunks:
    """
    Merge chunks into a single tree sequence. Adapted from `convert_long_arg.py`.
    Sets mutations.parent correctly (see https://github.com/popgenmethods/SINGER/issues/11)
    """
    input:
        ratemap = rules.chunk_chromosomes.output.ratemap, 
        metadata = rules.chunk_chromosomes.output.metadata,
        params = merge_chunks_params,
        recombs = lambda w: merge_chunks_input(w, "recombs")
    output:
        trees = "results/{chrom}/{chrom}.{rep}.trees"
    run:
        ratemap = pickle.load(open(input.ratemap, "rb"))
        metadata = pickle.load(open(input.metadata, "rb"))
        tables = tskit.TableCollection(sequence_length=ratemap.sequence_length)
        nodes, edges, individuals = tables.nodes, tables.edges, tables.individuals
        individuals.metadata_schema = tskit.MetadataSchema.permissive_json()
        for x in metadata: individuals.add_row(metadata=x)
        num_nodes, num_samples = 0, 0
        files = zip(input.params, input.recombs)
        for i, (params_file, recomb_file) in enumerate(files):
            node_file = recomb_file.replace("_recombs_", "_nodes_")
            mutation_file = recomb_file.replace("_recombs_", "_muts_")
            branch_file = recomb_file.replace("_recombs_", "_branches_")
            params = yaml.safe_load(open(params_file))
            block_start = params['start']
            # nodes
            node_time = np.loadtxt(node_file)
            num_nodes = nodes.num_rows - num_samples
            min_time = 0
            for t in node_time:
                if t == 0:
                    if i == 0:
                        nodes.add_row(flags=tskit.NODE_IS_SAMPLE, individual=num_samples // 2)
                        num_samples += 1
                else:
                    #TODO: assertion triggers rarely (FP error?)
                    #assert t >= min_time 
                    t = max(min_time + 1e-7, t)
                    nodes.add_row(time=t)
                    min_time = t
            # edges
            edge_span = np.loadtxt(branch_file)
            edge_span = edge_span[edge_span[:, 2] >= 0, :]
            length = max(edge_span[:, 1])
            parent_indices = np.array(edge_span[:, 2], dtype=np.int32)
            child_indices = np.array(edge_span[:, 3], dtype=np.int32)
            parent_indices[parent_indices >= num_samples] += num_nodes
            child_indices[child_indices >= num_samples] += num_nodes
            edges.append_columns(
                left=edge_span[:, 0] + block_start,
                right=edge_span[:, 1] + block_start,
                parent=parent_indices,
                child=child_indices
            )
            # mutations
            mutations = np.loadtxt(mutation_file)
            num_mutations = mutations.shape[0]
            mut_pos = 0
            for i in range(num_mutations):
                if mutations[i, 0] != mut_pos and mutations[i, 0] < length:
                    tables.sites.add_row(
                        position=mutations[i, 0] + block_start,
                        ancestral_state='0',
                    )
                    mut_pos = mutations[i, 0]
                site_id = tables.sites.num_rows - 1
                mut_node = int(mutations[i, 1])
                if (mut_node < num_samples):
                    tables.mutations.add_row(
                        site=site_id, 
                        node=int(mutations[i, 1]), 
                        derived_state=str(int(mutations[i, 3]))
                    ) 
                else:
                    tables.mutations.add_row(
                        site=site_id, 
                        node=int(mutations[i, 1]) + num_nodes, 
                        derived_state=str(int(mutations[i, 3]))
                    )    
        # rebuild mutations table in time order at each position
        mut_time = tables.nodes.time[tables.mutations.node]
        mut_coord = tables.sites.position[tables.mutations.site]
        mut_order = np.lexsort((-mut_time, mut_coord))
        mut_state = tskit.unpack_strings(
            tables.mutations.derived_state, 
            tables.mutations.derived_state_offset,
        )
        mut_state, mut_state_offset = tskit.pack_strings(np.array(mut_state)[mut_order])
        tables.mutations.set_columns(
            site=tables.mutations.site[mut_order],
            node=tables.mutations.node[mut_order],
            time=np.repeat(tskit.UNKNOWN_TIME, tables.mutations.num_rows),
            derived_state=mut_state,
            derived_state_offset=mut_state_offset,
        )
        tables.sort()
        tables.build_index()
        tables.compute_mutation_parents()
        ts = tables.tree_sequence()
        ts.dump(output.trees)


rule statistics:
    """
    Calculate per-chunk branch statistics ("fitted values") across MCMC iterations:

    - branch diversity
    - branch Tajima's D
    - branch site frequency spectra
    - coalescence rates
    """
    input:
        ratemap = rules.chunk_chromosomes.output.ratemap,
        trees = rules.merge_chunks.output.trees
    output:
        stats = "results/{chrom}/{chrom}.{rep,[0-9]+}.stats.p"
    run:
        ratemap = pickle.load(open(input.ratemap, "rb"))
        ts = tskit.load(input.trees)
        diversity = \
            ts.diversity(mode='branch', windows=ratemap.position, span_normalise=True) * MUTATION_RATE
        tajima_d = ts.Tajimas_D(mode='branch', windows=ratemap.position)
        tajima_d[ratemap.rate == 0.0] = np.nan
        folded_afs = \
            ts.allele_frequency_spectrum(mode='branch', span_normalise=True) * MUTATION_RATE * 2
        unfolded_afs = \
            ts.allele_frequency_spectrum(mode='branch', span_normalise=True, polarised=True) * MUTATION_RATE
        stats = {
            "diversity" : diversity, 
            "tajima_d" : tajima_d, 
            "folded_afs" : folded_afs, 
            "unfolded_afs" : unfolded_afs,
        }
        pickle.dump(stats, open(output.stats, "wb"))


def diagnostics_input(wildcards):
    dir = f"results/{wildcards.chrom}"
    out = expand(
        os.path.join(dir, "{chrom}.{rep}.stats.p"),
        chrom=wildcards.chrom,
        rep=range(MCMC_SAMPLES),
    )
    return out

rule diagnostics:
    """
    Make some diagnostic plots per chromosome:

    - per-base site diversity (from VCF) vs branch diversity ("fitted values" from trees) across chunks
    - branch diversity (average over chunks) over MCMC iterations
    - per-base site and branch diversity over genome position
    - the above, but with Tajima's D instead of nucleotide diversity
    - site allele frequency spectrum vs branch allele frequency spectrum (folded and unfolded)
    """
    input:
        ratemap = rules.chunk_chromosomes.output.ratemap,
        vcf_stats = rules.chunk_chromosomes.output.vcf_stats,
        stats = diagnostics_input,
    output:
        diversity_scatter = "results/{chrom}/diversity-scatter.png",
        diversity_trace = "results/{chrom}/diversity-trace.png",
        diversity_skyline = "results/{chrom}/diversity-skyline.png",
        tajima_d_scatter = "results/{chrom}/tajima-d-scatter.png",
        tajima_d_trace = "results/{chrom}/tajima-d-trace.png",
        tajima_d_skyline = "results/{chrom}/tajima-d-skyline.png",
        folded_afs = "results/{chrom}/folded-afs.png",
        unfolded_afs = "results/{chrom}/unfolded-afs.png",
    params:
        mcmc_samples = MCMC_SAMPLES,
        mcmc_burnin = MCMC_BURNIN,
        confidence_level = 0.0,
    script:
        "scripts/diagnostics.py"


rule coalescence_rates:
    """
    Calculate pair/cross coalescence rates across MCMC iterations:

    - per-chromosome pair coalescence rate, all samples
    - per-chunk pair coalescence rate, all samples
    - per-chromosome cross-coalescence rate, within/between populations (optional)
    - per-chunk cross-coalescence rate, within/between populations (optional)

    Rates are calculated within equally-spaced quantiles of the empirical
    distribution of coalescence times, separately for each window (e.g. the
    epoch breaks will vary across windows).
    """
    input:
        ratemap = rules.chunk_chromosomes.output.ratemap,
        trees = rules.merge_chunks.output.trees
    output:
        coalrate = "results/{chrom}/{chrom}.{rep,[0-9]+}.coalrate.p"
    params:
        coalrate_epochs = COALRATE_EPOCHS,
    script:
        "scripts/coalescence_rates.py"


def plot_coalescence_rates_input(wildcards):
    dir = f"results/{wildcards.chrom}"
    out = expand(
        os.path.join(dir, "{chrom}.{rep}.coalrate.p"),
        chrom=wildcards.chrom,
        rep=range(MCMC_SAMPLES),
    )
    return out

rule plot_coalescence_rates:
    """
    Plot pair/cross coalescence rates within equally spaced quantiles of the
    empirical coalescence time distribution.
    """
    input:
        ratemap = rules.chunk_chromosomes.output.ratemap,
        coalrate = plot_coalescence_rates_input,
    output:
        pair_coalescence_rates = "results/{chrom}/pair-coalescence-rates.png",
    params:
        coalrate_epochs = COALRATE_EPOCHS,
        mcmc_samples = MCMC_SAMPLES,
    script:
        "scripts/plot_coalescence_rates.py"
